정렬 알고리즘의 개요와 선택정렬(Selection Sort)

데이터를 특정 순서로 배열하는 알고리즘.
데이터 검색, 비교, 통계 분석 등에 자주 사용됨.

선택 정렬 (Selection Sort): 전체 배열 중 가장 작은 요소를 선택하여 배열의 앞쪽에 위치시키는 방식입니다.
시간 복잡도는 O(n^2)로, 단순하지만 큰 데이터에는 적합하지 않습니다.

버블 정렬 (Bubble Sort): 인접한 두 요소를 비교하여 필요한 경우 위치를 교환하면서 정렬하는 간단한 정렬 방식입니다.
시간 복잡도는 O(n^2)로, 비교적 비효율적입니다.

삽입 정렬 (Insertion Sort): 배열의 요소를 하나씩 정렬된 부분으로 삽입해 나가는 방식입니다.
평균 시간 복잡도는 O(n^2)이나, 거의 정렬된 데이터에 대해서는 효율적입니다.

퀵 정렬 (Quick Sort): 피벗을 기준으로 배열을 두 부분으로 분할하고, 각각의 부분을 재귀적으로 정렬합니다.
평균 시간 복잡도는 O(nlogn)이며, 효율적인 정렬 방법 중 하나입니다.

병합 정렬 (Merge Sort): 배열을 반으로 나눈 뒤 각각 정렬하여 병합하는 방식입니다.
시간 복잡도는 항상 O(nlogn)으로, 안정적이고 큰 데이터를 다룰 때 유용합니다.

힙 정렬 (Heap Sort): 힙 자료구조를 사용하여 최대값 또는 최소값을 빠르게 찾고 정렬하는 방식입니다.
시간 복잡도는 O(nlogn)이며, 메모리 효율이 높습니다.

셸 정렬 (Shell Sort): 삽입 정렬의 변형으로, 일정 간격을 두고 배열을 부분 정렬하여 전체 정렬을 수행합니다.
시간 복잡도는 평균적으로 O(n^3/2)에서 O(n^5/4)로, 간격을 줄여가며 정렬합니다.

기수 정렬 (Radix Sort): 숫자나 문자열을 자리수 단위로 정렬하는 방식입니다.
시간 복잡도는 O(d*(n+b))로, 정렬할 값의 길이와 기수에 따라 달라집니다.

계수 정렬 (Counting Sort): 정수 배열에서 특정 범위 내의 값들을 카운팅하여 정렬하는 방식입니다.
시간 복잡도는 O(n+k)로, 특정 상황에서 매우 효율적이나, 범위가 크면 비효율적일 수 있습니다.

버킷 정렬 (Bucket Sort): 데이터를 여러 버킷에 나누어 담은 뒤 각 버킷 내에서 정렬하여 합치는 방식입니다.
평균 시간 복잡도는 O(n+k)로, 특정 분포의 데이터에 대해 빠르게 동작합니다.

톱니 정렬 (Gnome Sort): 삽입 정렬의 일종으로, 잘못된 순서에 놓인 값을 발견하면 위치를 교환하며 정렬합니다.
시간 복잡도는 O(n^2)로 단순하지만 효율성은 떨어집니다.

콤 정렬 (Comb Sort): 버블 정렬의 개선된 형태로, 각 반복에서 요소를 떨어진 간격으로 비교합니다.
시간 복잡도는 O(n^2)에서 O(nlogn) 사이입니다.

이진 삽입 정렬 (Binary Insertion Sort): 삽입 정렬의 변형으로, 삽입 위치를 이진 탐색을 통해 찾는 방식입니다.
시간 복잡도는 O(n^2)로, 일반 삽입 정렬보다 조금 더 빠를 수 있습니다.

도트 정렬 (Bead Sort): 자연수 정렬에만 사용되며, 비즈 또는 구슬이 아래로 떨어지는 방식을 모방한 정렬입니다.
시간 복잡도는 O(n)으로 제한적이지만 빠릅니다.

번연 정렬 (Pancake Sort): 주어진 배열을 뒤집어가며 정렬하는 방식입니다.
시간 복잡도는 O(n^2)로, 주로 학술적 관심이 있습니다.